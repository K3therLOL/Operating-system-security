> 5. Изучите специальную символьную ссылку /proc/self, которая указывает на директорию текущего (self) процесса. Объясните результаты.
>
>  ```bash
>  $ echo $$
>  3203
>  $ ls -l /proc/self
>  lrwxrwxrwx. 1 root root 0 Oct 13 21:42 /proc/self -> 12485
>  ```

$ - это PID текущей обочки, а при исполнении программы `ls -l /proc/self` мы создали дочерний процесс оболочки с уже другим PID, который /proc/self нам и показал.

> 4. В левом окне остановите процесс. BASH вернет номер задания в квадратных скобках. Убедитесь, что процесс перестал писать в файл. Обратите внимание, что изменилось состояние процесса (ps j).

Вместо состояния Ss (ожидания, когда задача прекратиться) появилось состояние T (остановлен сигналом).

> 5. В левом окне выведите список заданий. Знаком + помечено текущее задание. Определите состояние процесса. Запустите задание в фоновом режиме. Убедитесь, что процесс снова продолжил писать в файл. Определите состояние процесса ещё раз.

Теперь состояние S (ожидания, когда задача прекратиться только уже в background).

> 3. Перенаправьте потоки stdout и stderr в файлы. Объясните результаты.
> 
> ```bash
> $ ls -l /proc/self/fd > /tmp/ls.out 2> /tmp/ls.err
> $ cat /tmp/ls.out 
> total 0
> lrwx------. 1 defanov defanov 64 Oct 14 00:09 0 -> /dev/pts/0
> l-wx------. 1 defanov defanov 64 Oct 14 00:09 1 -> /tmp/ls.out
> l-wx------. 1 defanov defanov 64 Oct 14 00:09 2 -> /tmp/ls.err
> lr-x------. 1 defanov defanov 64 Oct 14 00:09 3 -> /proc/12915/fd
> ```



