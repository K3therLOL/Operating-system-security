### Мониторинг процессов с помощью файловых систем procfs и sysfs

> 5. Изучите специальную символьную ссылку /proc/self, которая указывает на директорию текущего (self) процесса. Объясните результаты.
>
>  ```bash
>  $ echo $$
>  3203
>  $ ls -l /proc/self
>  lrwxrwxrwx. 1 root root 0 Oct 13 21:42 /proc/self -> 12485
>  ```

$ - это PID текущей обочки, а при исполнении программы `ls -l /proc/self` мы создали дочерний процесс оболочки с уже другим PID, который /proc/self нам и показал. 
Чтобы получить PID текущей оболочки, нужно воспользоваться командой `exec`.

### Механизм заданий (jobs). Выполнение процесса в основном и фоновом режимах

> 4. В левом окне остановите процесс. BASH вернет номер задания в квадратных скобках. Убедитесь, что процесс перестал писать в файл. Обратите внимание, что изменилось состояние процесса (ps j).

Вместо состояния Ss (ожидания, когда задача прекратиться) появилось состояние T (остановлен сигналом).

> 5. В левом окне выведите список заданий. Знаком + помечено текущее задание. Определите состояние процесса. Запустите задание в фоновом режиме. Убедитесь, что процесс снова продолжил писать в файл. Определите состояние процесса ещё раз.

Теперь состояние S (ожидания, когда задача прекратиться только уже в background).

### Работа процесса с файлами

> 3. Перенаправьте потоки stdout и stderr в файлы. Объясните результаты.
> 
> ```bash
> $ ls -l /proc/self/fd > /tmp/ls.out 2> /tmp/ls.err
> $ cat /tmp/ls.out 
> total 0
> lrwx------. 1 defanov defanov 64 Oct 14 00:09 0 -> /dev/pts/0
> l-wx------. 1 defanov defanov 64 Oct 14 00:09 1 -> /tmp/ls.out
> l-wx------. 1 defanov defanov 64 Oct 14 00:09 2 -> /tmp/ls.err
> lr-x------. 1 defanov defanov 64 Oct 14 00:09 3 -> /proc/12915/fd
> ```

Права доступа в данном случае обозначают параметры доступа для каждого открытого дескриптора. Поскольку `/dev/pts/0` - это TTY, то он открылся для чтения и для записи, `/tmp/ls.out` и `/tmp/ls.err` использовались для записи, потому что в них были перенаправлены `stdout` и `stderr`, а это потоки вывода.

> 4. Перенаправьте поток stdin. Объясните права доступа.

```bash
$ ls -l /proc/self/fd < /tmp/ls.in
total 0
lr-x------ 1 kether kether 64 2025-11-04 19:04 3 -> /proc/2004776/fd
lr-x------ 1 kether kether 64 2025-11-04 19:04 0 -> /tmp/ls.in
lrwx------ 1 kether kether 64 2025-11-04 19:04 1 -> /dev/pts/1
lrwx------ 1 kether kether 64 2025-11-04 19:04 2 -> /dev/pts/1
```

Видно, что файл `/tmp/ls.in` использовался только для чтения, потому что был stdin был перенаправлен в него терминалом. Также как файл `/proc/2004776/fd` был открыт командой `ls` во время выполнения только для чтения, поэтому и флаги `r-x`.

### Взаимодействие параллельных процессов через каналы

> 11. Изучите дескрипторы открытых файлов процессов cat. Как связаны их потоки stdout и stdin?

Через созданный в домашней директории файл `~/fifo1`.

> 12. Обратите внимание на то, что через именованные каналы могут общаться неродственные процессы. Объясните почему?

Ответ кроется в названии канала. Поскольку он именованный, то в файловой системе у него есть имя, поэтому любой процесс может по имени считать или написать в этот канал.

> 13. Организуйте чтение из канала в бесконечном цикле while с помощью команды read.

```bash
( while true; do read msg; echo $msg; done ) < ~/fifo1
```

### Изучение команды exec

> 1. Запустите дочерний shell и заместите коды порожденного процесса кодами команды ps -l. Обратите внимание на то, что PID процесса sh совпадает с PID процесса ps (13028). Объясните результаты.
> ```bash
> $ sh
> sh-4.3$ ps -l
> F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
> 0 S  1000  3203  3197  0  80   0 - 29691 wait   pts/0    00:00:00 bash
> 0 S  1000 13028  3203  0  80   0 - 28960 wait   pts/0    00:00:00 sh
> 0 R  1000 13030 13028  0  80   0 - 34450 -      pts/0    00:00:00 ps
> sh-4.3$ exec ps -l
> F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
> 0 S  1000  3203  3197  0  80   0 - 29691 wait   pts/0    00:00:00 bash
> 0 R  1000 13028  3203  0  80   0 - 34450 -      pts/0    00:00:00 ps
> $
> ```

Когда мы запустили `ps -l` без `exec`, то он запустился как дочерний процесс текущей оболочки с новом PID, а когда мы запустили с `exec`, то исходный код процесса оболочки заменился на исходный код команды `ls` (PID при этом не меняется). После выполнения процесс сразу умер, вернув нас в исходную оболочку.

> 3. Выведите информацию об открытых файлах процесса bash. Объясните позицию указателя чтения/записи (pos: 14).

Содержимое файла test.out: `Test3\nTest333\n" как раз размер заполненной части файла - 14 символов.

> 4. Откройте файл ~/test.out на чтение и свяжите его с дескриптором 4.
> ```bash
> $ cat ~/test.out 
>   Test3
>   Test333
> $ cat <&4
>   Test3
>   Test333
> $ cat ~/test.out 
>   Test3
>   Test333
> $ cat <&4
> $
> ```

Здесь 4 файловый дескриптор работает как обычный stdin линукса. В файле `~/test.out` находится буффер, который 4 дескриптор считывает. После чтения буффер закончился, там ничего нет, поэтому последняя команда вывела пустую строку в терминал.

> 6. Попробуйте вывести содержимое файла ~/test.out командой cat, используя два способа обращения к файлу: через дескриптор и через имя. Объясните результат.

`rm` удаляет название файла из файловой системы, но его содержимое и inode всё ещё содержится на диске. Дескрипторы всё ещё открыты и указывают на inode файла, что позволяет доступиться к его данным. Данные файла очистятся, только когда будет закрыт последний дескриптор, связанный с файлом:
```bash
exec >&3-
exec <&4-
```

### Изучение системных вызовов

> 5. Объясните полученные результаты.

В программе происходит пользовательская обработка сигналов. Если мы посылаем SIGSTOP или SIGCONT, то выводим в стандартный поток вывода информацию о том, что сигналы были перехвачены.
Если послать ребёнку сигнал SIGSTOP, то программа выйдет с соответствующей ошибкой. В заключении, если передать в программу параметр командной строки, то дочерний процесс вызовет функцию _exit и родительский процесс поймает соответствующий сигнал и выйдет с кодом возврата, равный переданному значению.

> 10. Объясните полученные результаты.

В программе происходит замена исходного кода процесса без создания нового с помощью `execve`. В него мы передаём название программы, которое мы передали через параметры командной строки, также передаём агрументы командной строки для этой программы и переменные окружения. Эта новая программа выводит параметры командной строки и переменных окружения.

> 13. Объясните полученные результаты.

Программа перехватывает сигнал SIGINT и отчитывается об этом в стандартном потоке вывода.

> 20. Измените программу таким образом, чтобы сигнал SIGINT игнорировался процессом.

```C
struct sigaction act;
sigemptyset(&act.sa_mask);
act.sa_flags = 0;
act.sa_handler = SIG_IGN; // changed to ignore flag
```

> 21. Объясните полученные результаты.

Теперь сигнал SIGINT полностью игнорируется без вывода в стандартный поток.

### Дополнительное задание. Разработка сценария

> Найти в системе все процессы, у которых различаются реальные и эффективные пользовательские идентификаторы.
> 
> Для обнаруженных процессов вывести имя программы.
> 
> Для тестирования можно использовать программу passwd.

Скрипт 01-real-effective-processes.sh выложен в текущей папке.

