### 1. Работа с командной оболочкой и справочной системой
> Работа в командной строке происходит в виде интерактивного диалога со специальной программой - командной оболочкой (Bash).
> В ней выполняются команды, имеющие интерфейс командной строки (далее - просто команды).

Помимо команд CLI (Command Line Interface), существуют команды не имеющие интерфейса командной строки. 
Например, программа с графическим интерфейсом пользователя (GUI), 
её можно запустить из консоли, но дальнейшее взаимодействие происходит через графический интерфейс. 


Другой пример, ядро операционной системы, которая не имеет своего интерфейса, но при этом взаимодействие с ней возможно через системные вызовы.

### 3. Работа с файловой системой
Каждому файлу в linux присвоен свой __inode__, который хранит в себе метаданные файла, например, ссылка на блок данных, то есть место, где физически на жёстком диске находится исходный файл. 
Также inode хранит имя владельца файла, права доступа, дату создания, дату последней модификации, дату последнего доступа и прочее. Часть этих метаданных можно посмотреть через команду:
```
ls -l file_name
```
Если скопировать файл командой cp:
```
cp file_name new_file_name
```
то у нового файла будет другой inode и место на диске. Но если прописать команду для создания ссылок ln:
```
ln file_name hard_link
```
то будет создан новый файл, который имеет тот же inode и находится в том же месте на диске. Этот новый файл называется __жесткая__ ссылка, если изменить её, то измениться и сам файл, на который он
ссылается. Если удалить hard link, то исходный файл не будет удалён, так как inode всё ещё остался.

Если добавить флаг -s вместе с командой ln:
```
ln -s file_name sym_link
```
то создатся так называемая __мягкая__ (или по-другому __символьная__) ссылка. Она работает точно также как и жесткая (если поменять ссылку, то исходный файл тоже поменяется), за исключением того, что
ссылается на конкретный файл, а не на inode. При удалении исходного файла, на который ссылается symbolic link, она перестаёт работать, так как inode файла был уничтожен. 
### 4. Конвейеры. Обработка текстовых файлов
> 4.1. Вывести на экран всех пользователей системы с сортировкой по алфавиту:

``` bash
cut -d: -f1 /etc/passwd | sort -d
```

> 4.2. Изменить предыдущую команду таким образом, чтобы помимо имени пользователя на экране также выводился его идентификатор. Подсказка: посмотрите содержимое файла /etc/passwd, чтобы найти, в каком из полей, разделенных двоеточием, находится UID:

``` bash
cut -d: -f1,3 /etc/passwd | column -ts: | less
```
> 4.4. Вывести на экран только имена пользователей, использующих командную оболочку /bin/bash, отсортировав их по алфавиту в обратном порядке:

``` bash
grep :/bin/bash /etc/passwd | cut -d: -f1 | sort -r
```
> 4.5. Выполнить сортировку установленных системных пакетов по размеру (большего к меньшему) и вывести первые 25 из них:

В моей операционной системе linux mint используется пакетный менеджер dpkg вместо rpm, но принцип остаётся тот же

``` bash
dpkg-query -W -f '${Package} ${Installed-Size;8}\n' | column -t | sort -k2,2 -rn | head -n 25
```

> 4.6. Вывести все файлы и каталоги из пакета man, подсчитать для каждого из них размер, игнорируя ошибки, и выполнить сортировку по размеру:
```bash
dpkg-query -W "man-db*" | xargs -l whereis | cut -d: -f2 | xargs -l du -b | sort -n
```
> 4.7. При помощи программы top вывести список работающих процессов и отсортировать их по имени процесса (аргумент команды sort заполнить самостоятельно):
```bash
top -b -n1 | sort -k2
```
У команды `top` есть шапка, поэтому лучше её вырезать, чтобы она не участвовала в сортировке листинга процессов:
```bash
top -b -n1 | tail -n+8 | sort -k2
```

> 4.8. Изменить вывод команды top таким образом, чтобы в первой колонке отображалось имя процесса, во второй - объём виртуальной памяти:
```bash
top -b -n1 | tail -n+7 | cut -c8- | tr -s ' ' '\t' | cut -f5,12
```
Комбинация команд сверху выведет сначала объем виртуальной памяти, а потом имя процесса, так как `cut` не может менять последовательность столбцов. Чтобы избежать
этого, следует использовать более функциональный инструмент парсинга столбцов `awk`:
```bash
top -b -n1 | tail -n+7 | awk '{ print $12, $5 }' | column -t
```

> 4.9. Вывести файл /etc/passwd в отсортированном по пользователям виде, заменив знаки двоеточия пробелами:
```bash
sort -k1 /etc/passwd | tr ':' ' '
```

> 4.10. Вывести файл /etc/passwd в отсортированном по пользователям виде в две колонки - в первой - имя пользователя, во второй - командная оболочка пользователя:
```bash
cut -d: -f1,7 /etc/passwd | sort -k1,1 | column -ts:
```
> 4.12. Выполнить анализ частоты появления каждого слова в файле user-manual.txt. Конвейер нужно строить по шагам, наблюдая за изменением результата. Определить этап получения первичной информации, этап обработки и этап представления результатов.

Поскольку user-manual.txt был удалён в одной из новых версий гита, возьмём на изучение файл README.md в той же папке `cd /usr/share/doc/git`.

Далее будут идти __регулярные__ выражения, про которые можно прочитать [тут](https://habr.com/ru/companies/ruvds/articles/327896/).

Первый способ решения задачи:
```bash
cat README.md | tr ' ' '\012' | tr '[:upper:]' '[:lower:]' | tr -d [:punct:] | grep -v '[^a-z]' | awk '!/^$/{print $0}' | sort | uniq -c | sort -rn | head
```
Пояснениe:
1. Выводим файл `README.md` в стандартный поток вывода.
2. Меняем все пробельные символы, символом с восьмеричным кодом 12, который соответствует переводу каретки.
3. Меняем все символы верхнего регистра на нижние.
4. Удаляем знаки пунктуации.
5. Удаляем все цифры (слова, в которых нет букв).
6. Удаляем пустые строки.
7. Сортируем.
8. Ищем количество каждого распарсенного слова в файле.
9. Сортируем по количеству в обратном порядке.
10. Находим первые 10 самых популярных слов.

Второй способ решения задачи:
```bash
cat README.md | tr -cs '[:alpha:]' '\n' | tr '[:upper:]' '[:lower:]' | sort | uniq -c | sort -rn | head
```
Различие в том, что в первом случае мы не считали за разделители знаки препинания и удалили их, а во втором случае считали, и поэтому во втором способе найденных слов будет больше.

### 6. Получение прав root
Для пользователя root пароль в linux mint не задан по умолчанию, поэтому нельзя просто так войти в режим суперпользователя через:
```bash
su - root
# Ввод пароля
```
Поскольку пароля нет, ввести его верно невозможно. Но это можно обойти с помощью временного увеличения привелегий `sudo`:
```bash
sudo su - root
# Ура, вы суперпользователь!
```
# Изучение команды find
> 1. Найдите все файлы и каталоги, имя которых содержит слово `pass`, поиск начните с корневого каталога.

```bash
sudo find / -name pass 2> /dev/null
```

> 2. Найдите все файлы и каталоги, имя которых содержит слово `pass` без учёта регистра, поиск начните с корневого каталога.

```bash
sudo find / -iname pass 2> /dev/null
```

> 3. Найдите все файлы и каталоги, имя которых содержит слово `pass`, ограничив глубину поиска одним каталогом, поиск начните с корневого каталога.

```bash
find / -maxdepth 1 -name pass 2> /dev/null
```

> 4. Найдите все файлы и каталоги, имена которых оканчиваются на .bin. Поиск необходимо выполнить в каталоге `/home`.

```bash
find /home -name "*.bin"
```
> 5. Найдите все __файлы__ (и только файлы) с расширением `bak` и удалите их.

Задача вызывает сложность, так как чтобы работать с директорией `-test dir` нужно экраинировать пробел с помощью обратного слеша, 
для этого нужно обработать строки, которые выводит `find`, сделаем это с помощью `sed`.
```bash
find . -type f -name "*.bak" | sed 's/[[:space:]]/\\ /g' | xargs rm
```
Заменяем пробел на backslash и пробел, тем самым мы экраинировали пробел и `rm` может спокойно распарсить путь до файла и удалить его.

> 6. Найдите все __файлы__ (и только файлы) с расширениями `txt` и `sh`.

Важно поставить круглые скобки вокруг опций с именами, иначе будет для одной из опций будет искаться файлы, а для другой опции будет поиск как файлов и директорий.

```bash
find . -type f \( -name "*.txt" -o -name "*.sh" \)
```

> 7. Найдите все __файлы__ (и только файлы) в текущем каталоге и выведите __только__ имя файла (без каталога), владельца, группу владельца, количество жёстких ссылок на этот файл и его размер в байтах.

```bash
find . -type f | sed 's/[[:space:]]/\\ /g' | xargs ls -la | tr -s '\t' | tr '/' ' ' | cut -d' ' -f2,3,4,5,12
```

> 8. Найдите все пустые __каталоги__ в текущем каталоге.

```bash
find . -empty -type d
```
> 9. Найдите все пустые __каталоги__ в текущем каталоге и удалите их.

```bash
find . -empty -type d | sed 's/[[:space:]]/\\ /g' | xargs rm -r
```
> 10. Найдите и удалите все пустые __файлы__ (и только файлы).

```bash
find . -empty -type f | sed 's/[[:space:]]/\\ /g' | xargs rm -r
```

> 11. Найдите все __файлы__ (и только файлы) в текущем каталоге, на которые есть хотя бы одна жёсткая ссылка.

```bash
find . -type f -links +0
```

> 12. Найдите файлы и каталоги в каталоге `/etc`, __не__ принадлежащие пользователю `root`.

```bash
sudo find /etc \! \( -user root \)
```

> 13. Найдите все __файлы__ (и только файлы), у которых __нет__ расширения `sh`.

```bash
find . -type f \! \( -name "*.sh" \)
```

> 14. Найдите все __файлы__ (и только файлы), у которых количество жёстких ссылок более двух.

```bash
find . -type f -links +2
```

> 15. Найдите все __файлы__ (и только файлы) в каталоге `/usr/bin`, последний доступ к которым осуществлялся более трёх месяцев назад.

```bash
find /usr/bin -type f -atime +90
```

> 16. Найдите все __файлы__ (и только файлы) в каталогах `/usr/bin` и `/usr/share`, созданные или изменённые в течении последних 10 дней.

```bash
find /usr/bin /usr/share -type f \( -ctime -10 -o -mtime -10 \)
```

> 17. Найдите и удалите все __файлы__ (и только файлы) в каталоге `/tmp`, которые не менялись более двух недель.

```bash
sudo find /tmp -type f -ctime +14
```

> 18. Найдите все __файлы__ (и только файлы) в каталоге `/usr/bin` с установленным флагом suid/sgid.

__SUID__ (Set User-ID) - разрешение, которое позволяет пользователю запустить файл, как будто он владелец файла. Иными словами, во время выполнения user-id этой команды будет user-id владельца, а не пользователя, запустивший этот файл. Это разрешение позволяет получить чуть больше контроля над файлом.

__SGID__ (Set Group-ID) - тоже самое разрешение, только при запуске group-id будет не пользовательский, а самого файла. 

Типичное использование этого разрешения: когда группа работает вместе над какой-то директорией, созданные файлы в этой директории будут иметь разный group-id пользователей группы. Чтобы это поменять, нужно присвоить `SGID` данной группе, тогда все созданные файлы в ней будет иметь group-id группы, а не разных пользователей.

Оба этих разрешения имеют бит `s`, вместо стандартного `x`.

```bash
find /usr/bin -type f \( -perm -"u=s" -o -perm -"g=s" \)
```

Используя команды `find` и `xargs` или параметр `-exec` команды find:

> 1. Найдите все __файлы__ (и только файлы) с расширением `txt` и подсчитайте количество строк во всех этих файлах.

```bash
find . -type f -name "*.txt" | sed 's/[[:space:]]/\\ /g' | wc -l
```

> 2. Найдите все каталоги с названием `.svn` и удалите их, включая содержимое этих каталогов, попутно выводя список удалённых файлов на экран.

```bash
find . -type d -name "*.svn" | sed 's/[[:space:]]/\\ /g' | xargs rm -rv
```

> 3. Найдите все __файлы__ (и только файлы) с расширением `sh` и добавьте им право на исполнение.

```bash
find . -type f -name "*.sh" | sed 's/[[:space:]]/\\ /g' | xargs chmod "+x"
```
> 4. Найдите все __файлы__ (и только файлы) с расширением conf в каталоге `/etc` и подсчитайте их суммарный размер, используя команду `du`.

```bash
sudo find /etc -type f -name "*.conf" | xargs du -c | tail -n1
```
Используя команду `grep`:

> 1. Из файла `/var/log/messages` вывести строки, содержащие ключевое слово `ERROR`, без учёта регистра.

У меня нет в linux mint файла `/var/log/messages`. Тестировал вместе него файл `var/log/kern.log`.

```bash
grep -riI "ERROR" /var/log/kern.log 
```

> 2. Из файла `/var/log/messages` вывести __количество__ строк, __не__ содержащих ключевое слово `ERROR`

```bash
grep -iIv "ERROR" /var/log/kern.log | wc -l
```

> 3. Из файла `/var/log/messages` вывести строки, содержащие __только слово `ERROR` целиком__, с учётом регистра.

```bash
grep -w "ERROR" /var/log/kern.log
```

> 4. Вывести количество строк из файла `/etc/group`, совпадающих с шаблоном `wheel`.

```bash
grep -iI "wheel" /etc/group | wc -l
```

> 5. Найти во всех файлах из текущего каталога и вложенных подкаталогов строки, содержащие шаблон `#!/bin/bash`.

```bash
grep -r '#!/bin/bash' .
```

> 6. Изменить предыдущую команду таким образом, чтобы она выводила дополнительные 10 строк после каждого найденного шаблона.

```bash
grep -r -A10 '#!/bin/bash' .
```

> 7. Найти во всех файлах с расширением sh из текущего каталога и вложенных подкаталогов строки, содержащие слово echo целиком. В выводе команды grep найденные слова выделите цветом.

```bash
grep --color=always -wr "echo" .
```

> 8. Измените предыдущую команду таким образом, чтобы команда grep отображала также имя файла и номер строки, в которой было обнаружено совпадение с шаблоном.

```bash
grep -wrn "echo" .
```
# Изучение сценариев Bash
Все сделанные скрипты выложены в директорию `script`.
