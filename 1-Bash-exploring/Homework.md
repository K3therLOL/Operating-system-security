### 1. Работа с командной оболочкой и справочной системой
> Работа в командной строке происходит в виде интерактивного диалога со специальной программой - командной оболочкой (Bash).
> В ней выполняются команды, имеющие интерфейс командной строки (далее - просто команды).

Помимо команд CLI (Command Line Interface), существуют команды не имеющие интерфейса командной строки. 
Например, программа с графическим интерфейсом пользователя (GUI), 
её можно запустить из консоли, но дальнейшее взаимодействие происходит через графический интерфейс. 


Другой пример, ядро операционной системы, которая не имеет своего интерфейса, но при этом взаимодействие с ней возможно через системные вызовы.

### 3. Работа с файловой системой
Каждому файлу в linux присвоен свой __inode__, который хранит в себе метаданные файла, например, ссылка на блок данных, то есть место, где физически на жёстком диске находится исходный файл. 
Также inode хранит имя владельца файла, права доступа, дату создания, дату последней модификации, дату последнего доступа и прочее. Часть этих метаданных можно посмотреть через команду:
```
ls -l file_name
```
Если скопировать файл командой cp:
```
cp file_name new_file_name
```
то у нового файла будет другой inode и место на диске. Но если прописать команду для создания ссылок ln:
```
ln file_name hard_link
```
то будет создан новый файл, который имеет тот же inode и находится в том же месте на диске. Этот новый файл называется __жесткая__ ссылка, если изменить её, то измениться и сам файл, на который он
ссылается. Если удалить hard link, то исходный файл не будет удалён, так как inode всё ещё остался.

Если добавить флаг -s вместе с командой ln:
```
ln -s file_name sym_link
```
то создатся так называемая __мягкая__ (или по-другому __символьная__) ссылка. Она работает точно также как и жесткая (если поменять ссылку, то исходный файл тоже поменяется), за исключением того, что
ссылается на конкретный файл, а не на inode. При удалении исходного файла, на который ссылается symbolic link, она перестаёт работать, так как inode файла был уничтожен. 
### 4. Конвейеры. Обработка текстовых файлов
> 4.1. Вывести на экран всех пользователей системы с сортировкой по алфавиту:

``` bash
cut -d: -f1 /etc/passwd | sort -d
```

> 4.2. Изменить предыдущую команду таким образом, чтобы помимо имени пользователя на экране также выводился его идентификатор. Подсказка: посмотрите содержимое файла /etc/passwd, чтобы найти, в каком из полей, разделенных двоеточием, находится UID:

``` bash
cut -d: -f1,3 /etc/passwd | column -ts: | less
```
> 4.4. Вывести на экран только имена пользователей, использующих командную оболочку /bin/bash, отсортировав их по алфавиту в обратном порядке:

``` bash
grep :/bin/bash /etc/passwd | cut -d: -f1 | sort -r
```
> 4.5. Выполнить сортировку установленных системных пакетов по размеру (большего к меньшему) и вывести первые 25 из них:

В моей операционной системе linux mint используется пакетный менеджер dpkg вместо rpm, но принцип остаётся тот же

``` bash
dpkg-query -W -f '${Package} ${Installed-Size;8}\n' | column -t | sort -k2,2 -rn | head -n 25
```

> 4.6. Вывести все файлы и каталоги из пакета man, подсчитать для каждого из них размер, игнорируя ошибки, и выполнить сортировку по размеру:
```bash
dpkg-query -W "man-db*" | xargs -l whereis | cut -d: -f2 | xargs -l du -b | sort -n
```
> 4.7. При помощи программы top вывести список работающих процессов и отсортировать их по имени процесса (аргумент команды sort заполнить самостоятельно):
```bash
top -b -n1 | sort -k2,2
```
> 4.8. Изменить вывод команды top таким образом, чтобы в первой колонке отображалось имя процесса, во второй - объём виртуальной памяти:
```bash
top -b -n1 | tail -n+7 | cut -c8- | tr -s ' ' '\t' | cut -f5,12
```

> 4.9. Вывести файл /etc/passwd в отсортированном по пользователям виде, заменив знаки двоеточия пробелами:
```bash
sort -k1,1 /etc/passwd | tr ":" " "
```

> 4.10. Вывести файл /etc/passwd в отсортированном по пользователям виде в две колонки - в первой - имя пользователя, во второй - командная оболочка пользователя:
```bash
cut -d: -f1,7 /etc/passwd | sort -k1,1 | column -ts:
```
> 4.12. Выполнить анализ частоты появления каждого слова в файле user-manual.txt. Конвейер нужно строить по шагам, наблюдая за изменением результата. Определить этап получения первичной информации, этап обработки и этап представления результатов.

Поскольку user-manual.txt был удалён в одной из новых версий гита, возьмём на изучение файл README.md в той же папке `cd /usr/share/doc/git`.

Далее будут идти __регулярные__ выражения, про которые можно прочитать [тут](https://habr.com/ru/companies/ruvds/articles/327896/).

Первый способ решения задачи:
```bash
cat README.md | tr ' ' '\012' | tr '[:upper:]' '[:lower:]' | tr -d [:punct:] | grep -v '[^a-z]' | awk '!/^$/{print $0}' | sort | uniq -c | sort -rn | head
```
Пояснениe:
1. Выводим файл `README.md` в стандартный поток вывода.
2. Меняем все пробельные символы, символом с восьмеричным кодом 12, который соответствует переводу каретки.
3. Меняем все символы верхнего регистра на нижние.
4. Удаляем знаки пунктуации.
5. Удаляем все цифры (слова, в которых нет букв).
6. Удаляем пустые строки.
7. Сортируем.
8. Ищем количество каждого распарсенного слова в файле.
9. Сортируем по количеству в обратном порядке.
10. Находим первые 10 самых популярных слов.

Второй способ решения задачи:
```bash
cat README.md | tr -cs '[:alpha:]' '\n' | tr '[:upper:]' '[:lower:]' | sort | uniq -c | sort -rn | head
```
Различие в том, что в первом случае мы не считали за разделители знаки препинания и удалили их, а во втором случае считали, и поэтому во втором способе найденных слов будет больше.

### 6. Получение прав root
Для пользователя root пароль в linux mint не задан по умолчанию, поэтому нельзя просто так войти в режим суперпользователя через:
```bash
su - root
# Ввод пароля
```
Поскольку пароля нет, ввести его верно невозможно. Но это можно обойти с помощью временного увеличения привелегий `sudo`:
```bash
sudo su - root
# Ура, вы суперпользователь!
```
# Изучение команды find
> 1. Найдите все файлы и каталоги, имя которых содержит слово `pass`, поиск начните с корневого каталога.

```bash
find / -name pass 2> /dev/null
```

> 2. Найдите все файлы и каталоги, имя которых содержит слово `pass` без учёта регистра, поиск начните с корневого каталога.

```bash
find / -iname pass 2> /dev/null
```

> 3. Найдите все файлы и каталоги, имя которых содержит слово `pass`, ограничив глубину поиска одним каталогом, поиск начните с корневого каталога.

```bash
find / -maxdepth 1 -name lib 2> /dev/null
```

> 4. Найдите все файлы и каталоги, имена которых оканчиваются на .bin. Поиск необходимо выполнить в каталоге `/home`.

```bash
find /home -name "*.bin"
```
> 5. Найдите все __файлы__ (и только файлы) с расширением `bak` и удалите их.

Задача вызывает сложность, так как чтобы работать с директорией `-test dir` нужно экраинировать пробел с помощью обратного слеша, 
для этого нужно обработать строки, которые выводит `find`. 
```bash
find . -type f -name "*.bak" | sed 's/[[:space:]]/\\ /g' | xargs rm
```
Заменяем пробел на backslash и пробел, тем самым мы экраинировали пробел и `rm` может спокойно распарсить путь до файла и удалить его.

> 6. Найдите все __файлы__ (и только файлы) с расширениями `txt` и `sh`.

Важно поставить круглые скобки вокруг опций с именами, иначе будет для одной из опций будет искаться файлы, а для другой опции будет поиск как файлов и директорий.

```bash
find . -type f \( -name "*.txt" -o -name "*.sh" \)
```

> 7. Найдите все __файлы__ (и только файлы) в текущем каталоге и выведите __только__ имя файла (без каталога), владельца, группу владельца, количество жёстких ссылок на этот файл и его размер в байтах.

> 8. Найдите все пустые каталоги в текущем каталоге.

```bash
find . -empty -type d
```
> 9. Найдите все пустые каталоги в текущем каталоге и удалите их.

```bash
find . -empty -type d | sed 's/[[:space:]]/\\ /g' | xargs rm -r
```
